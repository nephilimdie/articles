# Exception-Driven Application Flow in PHP (Laravel & Symfony)

This document is intended for senior backend developers, tech leads, and software architects working with medium-to-large PHP codebases (Laravel and/or Symfony). It assumes familiarity with modern PHP (>=8.1), OOP, SOLID principles, and layered application architectures.

This document defines:

* a complete architectural model for error handling
* strict, non-negotiable rules
* a reference implementation approach

covering HTTP APIs, CLI commands, and extensible transports (gRPC, async workers).

This document does not:

* replace framework documentation
* enforce a specific domain style (DDD on/off)
* describe observability stacks (ELK, OTEL)

---

## Introduction

This architecture exists to stop a slow, very real failure mode in PHP backends: **every team invents its own error-handling dialect**.

At first it looks harmless. One controller returns arrays, another throws, a third calls `abort()`. Six months later your API contract is a patchwork and the client has to guess what happened.

A concrete example (common in Laravel codebases): a controller that mixes **business meaning** with **policy** (status codes, payload shape, logging, and user-facing messages).

```php
<?php
// "Return arrays" style: policy leaks everywhere.
public function uploadThumbnail(Request $request): JsonResponse
{
    $width = (int) $request->input('width');
    $height = (int) $request->input('height');

    // Domain meaning: thumbnail is too small.
    // Policy decisions (problematic here): HTTP status, payload schema, logging, and message text.
    if ($width < 640 || $height < 360) {
        logger()->info('Thumbnail too small', ['width' => $width, 'height' => $height]);

        return response()->json([
            'success' => false,
            'error' => [
                // Some controllers use response_code, others don't. Some nest meta, others flatten it.
                'response_code' => 'THUMBNAIL_TOO_SMALL',
                'message' => 'Thumbnail too small',
                'meta' => ['width' => $width, 'height' => $height],
            ],
        ], 422);
    }

    // ... more checks, more duplicated mapping rules, more payload variations ...

    return response()->json(['success' => true]);
}
```

Now compare with an exception-driven flow:

```php
<?php
// "Throw meaning" style: domain/validation expresses semantics only.
public function uploadThumbnail(Request $request): JsonResponse
{
    $width = (int) $request->input('width');
    $height = (int) $request->input('height');

    VideoAssertions::thumbnailIsLargeEnough($width, $height);

    return response()->json(['success' => true]);
}
```

Here the controller stops being an error-policy factory. It expresses intent and delegates meaning to the domain. The boundary (global handler / middleware / subscriber) becomes the **single point** that decides, consistently:

* which transport status to use
* the exact error payload shape
* which `response_code` is exposed as contract
* what and how to log
* how to translate user-facing messages

One clarification up front: **this is not about using exceptions as a substitute for normal branching.** Exceptions represent abnormal states or boundary outcomes; if the caller can continue meaningfully, don’t throw.

The core idea is pragmatic:

**move all error policy out of core logic and enforce it at the boundary**.

Developers focus on meaning (what is valid, what is not, what must never happen). Everything else—logging, translation, serialization, protocol mapping—is centralized and enforced consistently.

### Contract

This document specifies an **exception-driven application flow** for PHP backends (Laravel) where semantic failures are expressed as typed exceptions and translated at the boundary into transport-specific responses.

An implementation conforming to this document:

* MUST model abnormal states as **semantic exceptions** (not boolean returns or ad-hoc arrays)
* MUST expose a stable, machine-readable **response_code** as the primary client contract
* MUST keep transport policy (HTTP status codes, exit codes, gRPC status, messages, logging strategy) **out of domain code**
* MUST normalize any `Throwable` into a canonical **ErrorEnvelope** via an ErrorAdapter
* MUST present errors through a consistent transport payload/schema (HTTP/CLI/gRPC)
* SHOULD translate human-facing messages only at the boundary (i18n), never in domain logic
* MUST test contracts by asserting `response_code` and status, not translated messages

Guiding principle:

**the domain throws meaning; the boundary translates meaning**.

---

## Core Principles (Non-Negotiable)

### Exception ≠ Control Flow

Exceptions represent **abnormal states or boundary outcomes**, not alternative execution paths. They must never replace conditional branching or be used for normal flow control.

**Wrong (exceptions as goto):**

```php
<?php
public function handle(Request $request): JsonResponse
{
    try {
        $user = $this->auth->requireUser($request);
        $this->service->doWork($user);
    } catch (Throwable $e) {
        // “Anything bad => 200 with success=false” or “just swallow and continue”.
        return response()->json(['success' => false]);
    }

    // Execution continues with unknown state.
    return response()->json(['success' => true]);
}
```

**Correct (exceptions for abnormal outcomes, handled at the boundary):**

```php
<?php
public function handle(Request $request): JsonResponse
{
    $user = $this->auth->requireUser($request); // may throw NotAuthenticated/NotAuthorized

    $this->service->doWork($user);              // may throw semantic domain exceptions

    return response()->json(['success' => true]);
}
```

Valid uses include authorization failures, invalid input, invariant violations, and impossible states. If the caller can continue execution meaningfully, an exception is the wrong tool.

### Assertion ≠ Business Decision

Assertions protect **domain invariants** and fail fast. They must never encode reversible business decisions or optional paths.

Put differently: assertions are for “this must never be false in a valid system state”, not for policy rules like “if risk_score > X then require extra verification” (that’s a business policy path, not an invariant).

### Boundary Owns Policy

The domain does not decide:

* HTTP status codes
* exit codes
* client messages
* logging strategies

All policy decisions belong to the application boundary.

**If your domain knows HTTP, you already lost.**

### Stable Contracts > Messages

Messages are for humans and change over time. Contracts are for machines and must remain stable. Clients must rely on contracts, not on messages.

---

## Exception-Driven Flow

The conceptual flow is:

1. The domain evaluates a rule
2. A rule violation produces a semantic failure
3. The failure is expressed as a typed exception
4. The exception propagates to the boundary
5. The boundary normalizes meaning, applies policy, and produces output

No intermediate handling is allowed unless explicit recovery is possible.

---

## `response_code` as Business Contract

Every error exposes a stable, machine-readable identifier called `response_code`.

Rules:

* stable over time
* unique within its domain
* language-independent
* not derived from messages
* independent from transport
* “MUST NOT reuse a response_code for a different meaning”
* “Changing text/translation MUST NOT change response_code”

HTTP status codes are too coarse and contextual to represent business meaning.

---

## ErrorCode Design (Domain-Scoped Enums)

A single global error enum does not scale. Each domain owns its own error codes.

The core idea is:

* each domain defines its own enum (VideoErrorCode, UserErrorCode, BillingErrorCode, ...)
* all enums implement a shared interface (`ErrorCodeInterface`)
* the enum also defines transport mappings (HTTP / CLI / gRPC) so that the mapping is versioned together with the business meaning

### Interface

```php
<?php
declare(strict_types=1);

interface ErrorCodeInterface
{
    /**
     * Stable business identifier (API contract).
     */
    public function responseCode(): string;

    /**
     * Translation key used by the boundary.
     */
    public function translationKey(): string;

    /**
     * Transport mappings.
     */
    public function httpStatus(): int;
    public function cliExitCode(): int;
    public function grpcStatus(): int;
}
```

### Example: Video domain enum

```php
<?php
declare(strict_types=1);

enum VideoErrorCode: string implements ErrorCodeInterface
{
    case THUMBNAIL_INVALID_DIMENSIONS = 'VIDEO_THUMBNAIL_INVALID_DIMENSIONS';
    case VIDEO_NOT_FOUND = 'VIDEO_NOT_FOUND';

    public function responseCode(): string
    {
        return $this->value;
    }

    public function translationKey(): string
    {
        return match ($this) {
            self::THUMBNAIL_INVALID_DIMENSIONS => 'errors.video.thumbnail_invalid_dimensions',
            self::VIDEO_NOT_FOUND => 'errors.video.not_found',
        };
    }

    public function httpStatus(): int
    {
        return match ($this) {
            self::THUMBNAIL_INVALID_DIMENSIONS => 422,
            self::VIDEO_NOT_FOUND => 404,
        };
    }

    public function cliExitCode(): int
    {
        return match ($this) {
            self::THUMBNAIL_INVALID_DIMENSIONS => 2,
            self::VIDEO_NOT_FOUND => 3,
        };
    }

    public function grpcStatus(): int
    {
        // Example mapping: 3=INVALID_ARGUMENT, 5=NOT_FOUND (gRPC status codes)
        return match ($this) {
            self::THUMBNAIL_INVALID_DIMENSIONS => 3,
            self::VIDEO_NOT_FOUND => 5,
        };
    }
}
```

Notes:

* keeping mappings in the enum prevents duplicated “code → transport mapping” tables scattered in handlers
* `translationKey()` is stable; the translated text is not

---

## ApiExceptionInterface

`ApiExceptionInterface` is the minimal contract required for a semantic exception to participate in this architecture.

The boundary depends on this **interface**, not on a specific base class.

```php
<?php
declare(strict_types=1);

interface ApiExceptionInterface extends Throwable
{
    public function codeEnum(): ErrorCodeInterface;

    /**
     * PSR-3 severity level (e.g. LogLevel::INFO).
     */
    public function logLevel(): string;

    /**
     * Translation placeholders.
     *
     * @return array<string,mixed>
     */
    public function messageParams(): array;

    /**
     * Extra structured info for logs (internal).
     *
     * @return array<string,mixed>
     */
    public function context(): array;

    /**
     * Extra structured info safe for clients.
     *
     * @return array<string,mixed>
     */
    public function publicMeta(): array;
}
```

---

## ApiException Base Class

`ApiException` is the semantic base class. Concrete exceptions should:

* declare an error code (domain enum)
* declare the log level (PSR-3)
* optionally provide structured context and safe public metadata

`ApiException` should *not* contain any transport or presentation behavior.

```php
<?php
declare(strict_types=1);

use Psr\Log\LogLevel;

abstract class ApiException extends Exception implements ApiExceptionInterface
{
    /**
     * Each exception must map to a domain-owned error code.
     */
    abstract public static function code(): ErrorCodeInterface;

    /**
     * PSR-3 severity. Concrete exceptions override via constant.
     */
    public const LOG_LEVEL = LogLevel::ERROR;

    final public function codeEnum(): ErrorCodeInterface
    {
        return static::code();
    }

    final public function logLevel(): string
    {
        return static::LOG_LEVEL;
    }

    /**
     * Translation placeholders.
     *
     * @return array<string,mixed>
     */
    public function messageParams(): array
    {
        return [];
    }


    /**
     * Extra structured info for logs (internal).
     *
     * @return array<string,mixed>
     */
    public function context(): array
    {
        return [];
    }

    /**
     * Extra structured info safe for clients.
     *
     * @return array<string,mixed>
     */
    public function publicMeta(): array
    {
        return [];
    }
}
```

---

## Domain Exceptions (Examples)

Domain exceptions represent specific, semantic failure cases. Each exception class must be precise, explicit, and owned by the domain that defines the rule.

### Authorization example

```php
<?php
final class UserNotAuthorizedException extends ApiException
{
    public const LOG_LEVEL = LogLevel::NOTICE;

    public static function code(): ErrorCodeInterface
    {
        return UserErrorCode::NOT_AUTHORIZED;
    }
}
```

### Validation-like example

```php
<?php
final class ThumbnailInvalidDimensionsException extends ApiException
{
    public const LOG_LEVEL = LogLevel::INFO;

    public function __construct(
        private int $width,
        private int $height
    ) {
        parent::__construct('Invalid thumbnail dimensions');
    }

    public static function code(): ErrorCodeInterface
    {
        return VideoErrorCode::THUMBNAIL_INVALID_DIMENSIONS;
    }

    public function publicMeta(): array
    {
        return ['width' => $this->width, 'height' => $this->height];
    }
}
```

These exceptions encode meaning only; no transport logic is present.

---

## Assertions

Assertions protect invariants and remove defensive branching from domain logic. They must fail fast and never attempt recovery.

```php
<?php
final class VideoAssertions
{
    public static function thumbnailIsLargeEnough(int $width, int $height): void
    {
        if ($width < 640 || $height < 360) {
            throw new ThumbnailInvalidDimensionsException($width, $height);
        }
    }
}
```

Assertions make invariants explicit, self-documenting, and trivially testable.

---

## ErrorEnvelope

The `ErrorEnvelope` is the internal, canonical representation of an error. All transports operate from this model.

It contains:

* the semantic error code (business contract)
* a `message_key` (translation key)
* optional `message_params` (translation placeholders)
* the severity level (PSR-3)
* public metadata (safe for clients)
* structured logging context (internal-only)

This guarantees a single source of truth for error handling.

### Reference implementation

```php
<?php
declare(strict_types=1);

final class ErrorEnvelope
{
    /**
     * @param array<string,mixed> $messageParams
     * @param array<string,mixed> $meta
     * @param array<string,mixed> $logContext
     */
    public function __construct(
        public readonly ErrorCodeInterface $code,
        public readonly string $messageKey,
        public readonly array $messageParams,
        public readonly string $logLevel,
        public readonly array $meta = [],
        public readonly array $logContext = [],
    ) {}

    public function responseCode(): string
    {
        return $this->code->responseCode();
    }
}
```

### Notes

* `meta` must contain only client-safe information (no stack traces, no SQL, no internal identifiers unless explicitly allowed).
* `logContext` is meant for structured logs and debugging. Keep it stable and machine-readable.
* `message_key` and `message_params` should come from the semantic error (exception/code). The final human message is resolved by the presenter at the boundary (not from the exception message).
* `log_level` is exposed to help clients classify errors for UI/telemetry.

---

## ErrorAdapter

The ErrorAdapter converts any `Throwable` into an `ErrorEnvelope`.

Responsibilities:

* read `ErrorCodeInterface` + log level + metadata from semantic exceptions
* wrap unknown throwables into a deterministic fallback semantic exception
* collect structured logging context

Unknown exceptions are treated as `INTERNAL_ERROR` by default.

### Adapter interface

```php
<?php
declare(strict_types=1);

interface ErrorAdapterInterface
{
    public function toEnvelope(Throwable $e): ErrorEnvelope;
}
```

### Semantic exceptions contract

The adapter must not depend on a specific base class. Any exception can participate as long as it implements `ApiExceptionInterface` (defined earlier).

### Default fallback exception

When the application hits an unknown `Throwable` (vendor bug, runtime error, `TypeError`, etc.), the boundary still needs a stable contract.

```php
<?php
declare(strict_types=1);

use Psr\Log\LogLevel;

final class InternalErrorException extends Exception implements ApiExceptionInterface
{
    public const LOG_LEVEL = LogLevel::ERROR;

    public function __construct(private readonly Throwable $original)
    {
        parent::__construct('Internal error', previous: $original);
    }

    public function codeEnum(): ErrorCodeInterface
    {
        return SystemErrorCode::INTERNAL_ERROR;
    }

    public function logLevel(): string
    {
        return self::LOG_LEVEL;
    }

    public function messageParams(): array
    {
        return [];
    }

    public function context(): array
    {
        return [
            'exception_class' => get_class($this->original),
            'exception_message' => $this->original->getMessage(),
            'file' => $this->original->getFile(),
            'line' => $this->original->getLine(),
        ];
    }

    public function publicMeta(): array
    {
        return [];
    }
}
```

### Default adapter (reference implementation)

The adapter does not translate messages. It only produces a canonical envelope with a translation key + params.

```php
<?php
declare(strict_types=1);

final class DefaultErrorAdapter implements ErrorAdapterInterface
{
    public function toEnvelope(Throwable $e): ErrorEnvelope
    {
        $semantic = $e instanceof ApiExceptionInterface
            ? $e
            : new InternalErrorException($e);

        $code = $semantic->codeEnum();

        return new ErrorEnvelope(
            code: $code,
            messageKey: $code->translationKey(),
            messageParams: $semantic->messageParams(),
            logLevel: $semantic->logLevel(),
            meta: $semantic->publicMeta(),
            logContext: $semantic->context(),
        );
    }
}
```

---

## Presenters

Presenters adapt an `ErrorEnvelope` to a specific transport.

They:

* format output (JSON, console text, gRPC error)
* apply transport mappings (HTTP status, exit code, gRPC status)

They never:

* decide error meaning
* create response codes
* contain business logic

### HTTP presenter

**Laravel**

```php
<?php
declare(strict_types=1);

use Symfony\Component\HttpFoundation\JsonResponse;

final class LaravelHttpErrorPresenter
{
    public function present(ErrorEnvelope $env): JsonResponse
    {
        $message = __($env->messageKey, $env->messageParams);

        return new JsonResponse([
            'success' => false,
            'error' => [
                'response_code' => $env->responseCode(),
                'log_level' => $env->logLevel,
                'message' => $message,
                'meta' => (object) $env->meta,
            ],
        ], $env->code->httpStatus());
    }
}
```

**Symfony**

```php
<?php
declare(strict_types=1);

use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Contracts\Translation\TranslatorInterface;

final class SymfonyHttpErrorPresenter
{
    public function __construct(private readonly TranslatorInterface $translator) {}

    public function present(ErrorEnvelope $env): JsonResponse
    {
        $message = $this->translator->trans($env->messageKey, $env->messageParams);

        return new JsonResponse([
            'success' => false,
            'error' => [
                'response_code' => $env->responseCode(),
                'log_level' => $env->logLevel,
                'message' => $message,
                'meta' => (object) $env->meta,
            ],
        ], $env->code->httpStatus());
    }
}
```

### CLI presenter

**Laravel**

```php
<?php
declare(strict_types=1);

final class LaravelCliErrorPresenter
{
    /**
     * @return int Exit code
     */
    public function present(ErrorEnvelope $env): int
    {
        $message = __($env->messageKey, $env->messageParams);

        fwrite(STDERR, sprintf("%s: %s
", $env->responseCode(), $message));

        if (!empty($env->meta)) {
            fwrite(STDERR, json_encode(['meta' => $env->meta], JSON_UNESCAPED_SLASHES) . "
");
        }

        return $env->code->cliExitCode();
    }
}
```

**Symfony**

```php
<?php
declare(strict_types=1);

use Symfony\Contracts\Translation\TranslatorInterface;

final class SymfonyCliErrorPresenter
{
    public function __construct(private readonly TranslatorInterface $translator) {}

    /**
     * @return int Exit code
     */
    public function present(ErrorEnvelope $env): int
    {
        $message = $this->translator->trans($env->messageKey, $env->messageParams);

        fwrite(STDERR, sprintf("%s: %s
", $env->responseCode(), $message));

        if (!empty($env->meta)) {
            fwrite(STDERR, json_encode(['meta' => $env->meta], JSON_UNESCAPED_SLASHES) . "
");
        }

        return $env->code->cliExitCode();
    }
}
```

### gRPC presenter (conceptual)

**Laravel**

```php
<?php
declare(strict_types=1);

final class LaravelGrpcErrorPresenter
{
    /**
     * Example return type: an array describing gRPC status + metadata.
     * A real implementation would return/throw the library-specific status object.
     *
     * @return array{status:int,message:string,metadata:array<string,string>}
     */
    public function present(ErrorEnvelope $env): array
    {
        return [
            'status' => $env->code->grpcStatus(),
            'message' => __($env->messageKey, $env->messageParams),
            'metadata' => [
                'response_code' => $env->responseCode(),
                'log_level' => $env->logLevel,
            ],
        ];
    }
}
```

**Symfony**

```php
<?php
declare(strict_types=1);

use Symfony\Contracts\Translation\TranslatorInterface;

final class SymfonyGrpcErrorPresenter
{
    public function __construct(private readonly TranslatorInterface $translator) {}

    /**
     * @return array{status:int,message:string,metadata:array<string,string>}
     */
    public function present(ErrorEnvelope $env): array
    {
        return [
            'status' => $env->code->grpcStatus(),
            'message' => $this->translator->trans($env->messageKey, $env->messageParams),
            'metadata' => [
                'response_code' => $env->responseCode(),
                'log_level' => $env->logLevel,
            ],
        ];
    }
}
```

---

## Laravel Implementation (Reference)

Laravel integrates this architecture through **Laravel’s default exception handler** (`App\Exceptions\Handler`).

The handler:

* normalizes any `Throwable` via the ErrorAdapter
* logs using Laravel’s logger (`logger()`)
* serializes a consistent JSON error payload via the HTTP presenter

Controllers and services never handle errors explicitly unless performing recovery.

### Wiring (service container)

```php
<?php
use Illuminate\Support\ServiceProvider;

final class ErrorHandlingServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        $this->app->singleton(ErrorAdapterInterface::class, DefaultErrorAdapter::class);
        $this->app->singleton(LaravelHttpErrorPresenter::class);
    }
}
```

### Using Laravel’s default Handler

Keep the framework handler class and register a renderable callback. No constructor DI, no custom handler implementation.

```php
<?php
declare(strict_types=1);

namespace App\Exceptions;

use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Symfony\Component\HttpFoundation\JsonResponse;
use Throwable;

final class Handler extends ExceptionHandler
{
    public function register(): void
    {
        $this->renderable(function (Throwable $e, $request): JsonResponse {
            $env = app(ErrorAdapterInterface::class)->toEnvelope($e);

            // Use Laravel logging as-is. This guide does not prescribe logging strategy.
            logger()->log($env->logLevel, $e->getMessage(), $env->logContext + ['exception' => $e]);

            return app(LaravelHttpErrorPresenter::class)->present($env);
        });
    }
}
```

### Example controller usage

```php
<?php
declare(strict_types=1);

use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\JsonResponse;

final class VideoController
{
    public function uploadThumbnail(Request $request): JsonResponse
    {
        $width = (int) $request->input('width');
        $height = (int) $request->input('height');

        VideoAssertions::thumbnailIsLargeEnough($width, $height);

        return response()->json(['success' => true]);
    }
}
```

---

## Symfony Implementation (Reference)

Symfony integrates via:

* kernel exception listeners for HTTP
* console exception handlers for CLI

Both reuse the same ErrorAdapter and presenters, ensuring consistent behavior across entry points.

### HTTP: Kernel exception subscriber

```php
<?php
declare(strict_types=1);

use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\HttpKernel\Event\ExceptionEvent;
use Symfony\Component\HttpKernel\KernelEvents;

final class ApiExceptionSubscriber implements EventSubscriberInterface
{
    public function __construct(
        private readonly ErrorAdapterInterface $adapter,
        private readonly SymfonyHttpErrorPresenter $presenter,
        private readonly \Psr\Log\LoggerInterface $logger,
    ) {}

    public static function getSubscribedEvents(): array
    {
        return [KernelEvents::EXCEPTION => 'onKernelException'];
    }

    public function onKernelException(ExceptionEvent $event): void
    {
        $e = $event->getThrowable();
        $env = $this->adapter->toEnvelope($e);

        $this->logger->log($env->logLevel, $e->getMessage(), $env->logContext + ['exception' => $e]);

        $event->setResponse($this->presenter->present($env));
    }
}
```

### CLI: Console base command (recovery boundary)

```php
<?php
declare(strict_types=1);

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Throwable;

abstract class SafeCommand extends Command
{
    public function __construct(
        private readonly ErrorAdapterInterface $adapter,
        private readonly SymfonyCliErrorPresenter $presenter,
        private readonly \Psr\Log\LoggerInterface $logger,
        ?string $name = null
    ) {
        parent::__construct($name);
    }

    final protected function execute(InputInterface $input, OutputInterface $output): int
    {
        try {
            return $this->executeSafe($input, $output);
        } catch (Throwable $e) {
            $env = $this->adapter->toEnvelope($e);

            $this->logger->log($env->logLevel, $e->getMessage(), $env->logContext + ['exception' => $e]);

            return $this->presenter->present($env);
        }
    }

    abstract protected function executeSafe(InputInterface $input, OutputInterface $output): int;
}
```

---

## Logging Strategy

Use your framework’s logger.

This guide does not prescribe how you configure logging, handlers, formatters, or stack trace policies.

Minimum expectations:

* never leak stack traces to clients
* keep log context structured and stable

---

## Performance: Cost of Exceptions in PHP

Exceptions in PHP are **cheap to have** (a `try/catch` on the happy path) but **expensive to throw**.

Rule of thumb:

* keep exceptions for **rare, abnormal** states
* never use them as normal flow control in hot paths (loops, parsers, validators)
* if you see high exception volume in production, **profile it**: the cost is often dominated by stack trace capture + logging

(Details and benchmarks moved to a dedicated article.)

References:

* [1] PHP.Watch — “Performance Impact of PHP Exceptions” (2020-09-08)
* [2] Datadog — “Why care about exception profiling in PHP?”

---

## try/catch Usage Rule

try/catch blocks are allowed only for explicit recovery or fallback.

```php
<?php
try {
    $service->execute();
} catch (ThumbnailInvalidDimensionsException $e) {
    $this->useDefaultThumbnail();
}
```

Catching without recovery is forbidden.

---

## Testing Strategy

Tests are split by responsibility.

### Domain tests

Domain tests assert which exception is thrown and its semantics, without involving HTTP serialization.

```php
<?php
public function test_thumbnail_too_small_throws_exception(): void
{
    $this->expectException(ThumbnailInvalidDimensionsException::class);

    VideoAssertions::thumbnailIsLargeEnough(320, 240);
}
```

### Boundary tests (HTTP)

Boundary tests assert the public contract: stable `response_code`, status, and structured payload.

```php
<?php
public function test_http_payload_contains_response_code(): void
{
    $response = $this->postJson('/api/video/thumbnail', [
        'width' => 320,
        'height' => 240,
    ]);

    $response
        ->assertStatus(422)
        ->assertJsonPath('success', false)
        ->assertJsonPath('error.response_code', 'VIDEO_THUMBNAIL_INVALID_DIMENSIONS');
}
```

Rule: tests must never assert translated messages (they change).

---

## Conceptual Workflow Diagram

```mermaid
flowchart TD
  A[Intent] --> B[Domain Logic]
  B -->|Valid| C[Continue]
  B -->|Invalid| D[Semantic Failure]
  D --> E[Normalize Meaning]
  E --> F[Apply Policy]
  F --> G[Log]
  F --> H[Present]
```

The workflow separates meaning, policy, and transport.

---

## Anti-Patterns

* using exceptions for normal flow
* catching and swallowing errors
* leaking stacktraces to clients
* unstable or reused response codes
* global error enums

---

## Migration Strategy

1. Freeze error response schema
2. Introduce ErrorCodeInterface and ApiException
3. Add adapters and presenters
4. Migrate critical paths first
5. Enforce rules via code review

---

## ADR (Architecture Decision Record)

**ADR-004 – Exception-Driven Application Flow**

Context: error handling is inconsistent and scattered.

Decision: model abnormal states as semantic exceptions and translate them at the boundary.

Consequences:

* consistent APIs
* cleaner domain code
* stricter discipline required

---

## Conclusion

This architecture is not about throwing exceptions everywhere. It is about making abnormal states explicit, centralizing error policy, and protecting business logic from transport concerns.

Used with discipline, it scales across HTTP, CLI, gRPC, and asynchronous systems.
